**Owner:** Icebreakers

# Overview
The browser context mounts a complete react/redux application in isolation and allows one to interact with it and make assertions about state while isolating any external dependencies. The goal of this library was to mimic an end-to-end testing framework syntax to remain familiar to testers. The interaction helpers make heavy use of [enzyme](https://github.com/airbnb/enzyme) and [chai-enzyme](https://github.com/producthunt/chai-enzyme). 

The context relies on a DOM being present (eg. PhantomJS, jsdom) and is specifically intended to test react/redux applications.

The browser context is disposable and can be recreated before each test to ensure a pristine application. The browser context can also be kept alive between multiple tests should this be necessary for performance reasons. The browser context is relatively expensive to create. Keeping the browser context alive between multiple tests may result in compromised state.

## Usage

The following is a simple example of how to use the browser context in a mocha test:
```javascript
describe('a basic example', () => {
  let browser;
  let investorDashboard;

  beforeEach(() => {
    browser = new Browser(<RootElement />, store);
  });
  
  afterEach(() => browser.shutdown());

  it('navigates to dashboard page', () => {
    browser.bff.get(`${bffUrl}/search`, successResponse(SUCCESS_RESPONSE));

    return browser
      .visit('/example')
      .fillIn('.my-input', 'Test Data')
      .click('.my-button')
      .expect('.header', (header) => header.to.have.text('Success'));
  });
});

```

**Take Note:** The `browser.shutdown()` command must be called when the browser context is finished being used. This unmounts the application from the DOM and disables the mocking of any http requests. Skipping this step will result in degraded test performance and http request errors.

### Application Specific Setup
Each application may have specific initialisation requirements. To that end it is advisable to create a helper script that sets up your application as required before creating a Browser instance. 

The following is a simple example of a helper to set up a react/redux application and create the browser context:
```javascript
/* test-context.jsx */
import React from 'react';
import { browserHistory } from 'react-router';
import { syncHistoryWithStore } from 'react-router-redux';
import Browser from '@agct/react-common/dist/utils/test/browser';
import configureStore from 'store/configureStore';
import Application from 'Application';

const store = configureStore();
const history = syncHistoryWithStore(browserHistory, store);

export default function createBrowser() {
  return new Browser(<Application store={store} history={history} />, store);
}
```

You can then import this for use in your tests:
```javascript
/* Search.test.jsx */
import createBrowser from '../helpers/test-context';
describe('a basic example', () => {
  let browser;
  let investorDashboard;

  beforeEach(() => {
    browser = createBrowser();
  });
  ...
});
```

# Technical Details
## Browser
Due to how the redux lifecycle works the browser context needs to push all interactions and assertions into the next iteration of the javascript event loop. It does this by creating a chain of promises which resolve in the next loop. This adds several complications to the use of the browser context:
  
  * You need to return the browser context at the end of each test or pass mocha's `done` call back to the browsers `then` function. eg. `browser.doSomething().then(done)`
  * All interactions must be added to the promise chain.
  
The browser context mimics the promise interface. By returning this at the end of the test mocha knows to wait for all the steps to finish. 

The browser exposes a live [Pretender](https://github.com/pretenderjs/pretender) instance at it's `bff` property to enable mocking out the bff server responses. Pretender will raise an exception if an unexpected request is made.

```javascript
browser.bff.get('/example', successResponse({data: 'Example'}));
```

A couple of response helpers are provided in the [responses file](./responses.js) that make creating Pretender responses easy, specifically: `jsonResponse`, `successResponse`, `internalErrorResponse`.


### `new Browser(application, store)`
The constructor **mounts the application** in the DOM and **creates a pretender instance** to mock http requests.

#### Arguments
1. `application`: A react/redux application root. Usually a `<Provider />` component.
2. `store` is the instance of the redux store.
   
#### Examples
```javascript
const store = configureStore();
const history = syncHistoryWithStore(browserHistory, store);

const browser = new Browser(<Application store={store} history={history} />, store);
```

### `shutdown()`
Unmounts the application and shuts down the pretender instance. 

#### Examples
```javascript
let browser;
beforeEach(() => { browser = new Browser(application, store); })
afterEach(() => { browser.shutdown() });
```

### `andThen(callback)`
The `andThen` helper is a low level way to add steps to the promise chain. Most test should only require higher level interactions via the provided interaction helpers but andThen is a flexible method to use if the helpers can't do what's required.

#### Arguments
1. `callback`: A callback with the signature `callback(rootNode, store)`  
   `rootNode` is the root node of the application wrapped in an enzyme `ReactWrapper`.  
   `store` is the instance of the redux store. You can call `dispatch` on this to interact directly with the store.
   
#### Examples
```javascript
import { expect } from 'chai';
import { push } from 'react-router-redux';

browser
  .andThen((rootNode, store) => dispatch(push('/example'))
  .andThen((rootNode, store) => rootNode.find('.button').simulate('click'))
  .andThen((rootNode, store) => expect(rootNode.find('.header')).to.have.text('Success'))
```

### `then(callback)`
Mimics a promise interface that resolves when all the browser steps are done. Useful for signalling the end of the promise chain at the end of mocha tests.

#### Arguments
1. `callback`: A callback with the signature `callback(resolve, error)`

#### Examples
```javascript
describe('Browser then', () => {
  it('mimics a promise interface', (done) => {
    new Browser(application, store)
      .andThen((rootNode, store) => rootNode.find('.button').simulate('click'))
      .then(done);
  });
  /* is equivalent to */
  it('mimics a promise interface', () => {
    return new Browser(application, store)
      .andThen((rootNode, store) => rootNode.find('.button').simulate('click'))
  });
});
```

### `use(...args)`
Extends the browser instance with the given functions binding them to the browser context. Useful for abstracting multiple interactions into higher level steps.

#### Examples
```javascript
function fillInForm(name, age) {
  this
    .fillIn('.name', name)
    .fillIn('.age', age);
    .submit('form');
}

function assertSummary(name, age) {
  this
    .expect('.name-label', (label) => label.to.have.text(name))
    .expect('.age-label', (label) => label.to.have.text(age));
}

new Browser(application, store)
  .use(fillInForm, assertSummary)
  .fillInForm('Example User', 18)
  .assertSummary('Example User', 18);

```

## Interactions
The library provides several interaction helpers that wrap the `andThen` function to interact with the DOM and the application. These can be found in the [interactions file](./test/interactions.js). These interactions can and should be added to when required.

The helper functions all take the root element as their first argument. The browser context is automatically extended with all the helpers at run time and transparently passes the root node to the interaction helper. For example, the `fillIn` helper has the signature `fillIn(rootElement, selector, value)` but is called on the browser context with the signature `browser.fillIn(selector, value)`. `rootElement` is passed in transparently.

The helper functions resolve the selector intelligently. If the selector is a string it the element is searched for on the root element of the application. eg. `rootElement.find(selector).first()`. If the selector is a function the function is called with the rootElement as it's only argument. eg. `selector(rootElement)`. This allows for complex selectors in the test file.

#### Examples
```javascript

browser
  .click('.button')
  .fillIn(
    /* Complex Selector Logic */
    (root) => root.find('.card').at(3).find('.name-input'),
    'Example User'
  )
```

The following interactions exist:

### `click(rootElement, selector)`
Simulates the click event for an element with the given selector.

#### Arguments
1. `rootElement`: The root element of the application.
2. `selector`: Either a string or a function that returns an element given the root element.

#### Examples
```javascript
browser
 .click('.button')
```

### `findThen(rootElement, ([selector]|callback), [callback])`
Finds and element and then passes it to the callback.

#### Arguments
1. `rootElement`: The root element of the application.
2. `selector': Optional. Either a string or a function that returns an element given the root element.
3. `callback`: If a selector is given the callback is passed the found element.  
               If no selector is given the callback is passed the root element.

#### Examples
```javascript
browser
 .findThen((root) => expect(root).to.have.text('Success'))
 .findThen('.header', (header) => expect(header).to.have.text('HEADER'));
```

### `expect(rootElement, ([selector]|callback), [callback])`
Finds an element, wraps it in chai `expect()` and passes it to the callback. Similar to [`findThen`](#findThen).

#### Arguments
1. `rootElement`: The root element of the application.
2. `selector': Optional. Either a string or a function that returns an element given the root element.
3. `callback`: If a selector is given the callback is passed the found element wrapped in chai's `expect`.  
               If no selector is given the callback is passed the root element wrapped in chai's `expect`.

#### Examples
```javascript
browser
 .expect((root) => root.to.have.text('Success'))
 .expect('.header', (header) => header.to.have.text('HEADER'));
```

### `findItemAt(rootElement, selector, index, callback)`
Finds one element from a matching collection and then passes it to the callback.

#### Arguments
1. `rootElement`: The root element of the application.
2. `selector': Either a string or a function that returns an element given the root element.
3. `index`: The zero-based index of the element to pass to the callback. Maps to enzyme's `at()` function;
4. `callback`: The callback is passed the found element.

#### Examples
```javascript
browser
 .findItemAt('.card', 2,  (card) => expect(card).to.have.text('Three'));
```

### `findItemAt(rootElement, selector, index, callback)`
Finds one element from a matching collection, wraps it in chai's `expect()` and then passes it to the callback.

#### Arguments
1. `rootElement`: The root element of the application.
2. `selector': Either a string or a function that returns an element given the root element.
3. `index`: The zero-based index of the element to pass to the callback. Maps to enzyme's `at()` function;
4. `callback`: The callback is passed the found element wrapped in expect.

#### Examples
```javascript
browser
 .findItemAt('.card', 2,  (card) => expect(card).to.have.text('Three'));
```

### `expectText(rootElement, selector, text)`
Finds an element and asserts it has the given text.

#### Arguments
1. `rootElement`: The root element of the application.
2. `selector': Either a string or a function that returns an element given the root element.
3. `text`: The text to assert against. Uses chai's `to.have.text()` function.


#### Examples
```javascript
browser
 .expectText('.header', 'Success');
```

### `expectValue(rootElement, selector, text)`
Finds an element that has a value (eg <input>) and asserts it has the given value.

#### Arguments
1. `rootElement`: The root element of the application.
2. `selector': Either a string or a function that returns an element given the root element.
3. `value`: The value to assert against. Uses chai's `to.have.value()` function.


#### Examples
```javascript
browser
 .expectValue('.input', 'Example Value');
```

### `fillIn(rootElement, selector, text)`
Finds an element and simulates focus, change and blur events while changing value.

#### Arguments
1. `rootElement`: The root element of the application.
2. `selector': Either a string or a function that returns an element given the root element.
3. `value`: The value to give to the element..


#### Examples
```javascript
browser
 .fillIn('.input', 'Example Value');
```

### `select(rootElement, selector, textValue)`
Finds a ag-dropdown element and simulates all the relevent events to set the selected value.

#### Arguments
1. `rootElement`: The root element of the application.
2. `selector': Either a string or a function that returns an element given the root element.
3. `textValue`: The text of the option to select.


#### Examples
```javascript
browser
 .select('.dropdown', 'Example Value');
```

### `submit(rootElement, selector)`
Finds an submits a form element simulating all relevant events.

#### Arguments
1. `rootElement`: The root element of the application.
2. `selector': Either a string or a function that returns an element given the root element.


#### Examples
```javascript
browser
 .select('.dropdown', 'Example Value');
```
## Store Helpers
In addition to the more mundane interactions the browser also exposes a couple of helpers that allow us to directly interact with the store:

### `dispatch(action)`
Dispatches the given action to the store directly. This can be helpful in getting the store to a required state for a test.

#### Arguments
1. `action`: A redux action.


#### Examples
```javascript
function removeTodo(id) {
  return {
    type: 'todos/destroy',
    payload: id,
  };
}

browser
  .dispatch(removeTodo(1));
```

### `visit(path, params={})`
Dispatches a react-router push action to the store to navigate to a page.

#### Arguments
1. `path`: A path relative to the application root. 
2. `params`: Parameters to build the path.


#### Examples
```javascript
browser
  .visit('/search')
  .visit('/members/:id', { id: 1 });
```

## PageObjectBrowser
PageObjectBrowser extends Browser with [page object](http://martinfowler.com/bliki/PageObject.html) functionality. Using page objects allows for more resilient tests that are easier to maintain.

Each page object definition usually contains the page url, some selectors that map to elements on the page and some actions to interact with the page. The following is a simple example of a page object description:

```javascript
const path = '/search';
const elements = {
    input: 'input[type="text"]',
    form: '.search-form',
    submitButton: 'input[type="submit"]',
};
const actions = {
  searchFor(searchTerm) {
    const { input, form } = elements;
    this
      .fillIn(input, 'Example')
      .submit(form);
  },
};

export default { path, elements, actions };
```
Page objects can be used in tests as follows:

```javascript

const { input, form, submitButton } = searchPage.elements;

browser
  .visit(searchPage)
  .fillIn(input, "Example")
  .submit(form);

```
The PageObject browser exposes two ways to load a page object into context: `visit` and `page`.

### `page(pageObject)`
Extends the browser context with any actions in the given page object. `page` also removes any actions from previous page objects from the browser context. This is useful if another interaction has navigated the browser to a page and you'd like to load a page object.

#### Arguments
1. `pageObject`: A page object description containing at least one action.


#### Examples
```javascript
const searchPage = { actions: { function() search() { ... } } };
const browsePage = { actions: { function() browse() { ... } } };

browser
  .visit('/search')
  .page(searchPage)
  .search()
  .page(browsePage)
  .browse();
```

### `visit(pageObject)`
Navigates to the path property of the page object description if it exists and then extends the browser context with any actions in the given page object. Similar to `page`, `visit` also removes any actions from previous page objects from the browser context.

#### Arguments
1. `pageObject`: A page object description containing at least one action.


#### Examples
```javascript
const searchPage = { path: '/search/:term', actions: { function() search() { ... } } };
const browsePage = { actions: { function() browse() { ... } } };

browser
  .visit(searchPage, { term: 'Example' })
  .search()
  .page(browsePage)
  .browse();
```
