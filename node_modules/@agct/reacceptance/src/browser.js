import _ from 'lodash';
import Pretender from 'pretender';
import { mount } from 'enzyme';
import * as domInteractions from './dom-interactions';
import * as storeInteractions from './store-interactions';
import { fixture } from './response-object';

const DEBUG = false;

export function unhandledRequest(method, path, bff) {
  const knownUrls = _.keys(bff.__responses).join('\n\t');
  const errorString =
    'Unmocked Request\n' +
    'Unhandled Url\n' +
    `\t${path}-${method}\n` +
    'Mocked Urls:\n' +
    `\t${knownUrls}`;
  console.error(errorString); // eslint-disable-line
  throw new Error(errorString);
}

class Browser {
  constructor(application, store) {
    this._promise = Promise.resolve();
    this.store = store;
    this.application = application;
    this.bff = new Pretender();
    this.bff.unhandledRequest = (method, path) =>
      unhandledRequest(method, path, this.bff);
    this.use(fixture);
    this._ = this.call;
  }

  mount(targetElement) {
    if (!this.application) {
      throw new Error('Cannot mount an empty application');
    }

    this.targetElement = targetElement;

    if (!this.targetElement) {
      this.targetElement = document.createElement('div');
      this.targetElement.id = 'app-container';
    }

    if (!document.body.contains(this.targetElement)) {
      document.body.appendChild(this.targetElement);
    }

    this.rootNode = mount(this.application, { attachTo: this.targetElement });
    this.mounted = true;
  }

  shutdown() {
    this.bff.shutdown();
    if (this.mounted) {
      this.rootNode.unmount();
      this.targetElement.remove();
    }
  }

  andThen(callback, name) {
    this._promise = this._promise.then(() => new Promise((resolve, reject) =>
      setTimeout(() => {
        // eslint-disable-next-line no-console
        if (DEBUG) console.debug('Starting andThen ', name);
        try {
          resolve(callback(this.rootNode, this.store, this.bff));
        } catch (error) {
          reject(error);
        }
        // eslint-disable-next-line no-console
        if (DEBUG) console.debug('Resolving andThen: ', name);
      }, 0)
    ));
    return this;
  }

  then(resolve, reject) {
    return this._promise.then(resolve).catch(reject);
  }

  call(helper, ...args) {
    if (DEBUG && helper.name) {
      // eslint-disable-next-line no-console
      console.debug(helper.name);
    }

    return helper.call(this, ...args);
  }

  use(...args) {
    _.forEach(args, (helper) => {
      this[helper.name] = (...helperArgs) => {
        helper.apply(this, helperArgs);
        return this;
      };
    });
    return this;
  }
}


/* eslint-disable no-console, no-return-assign, func-names */
_.forOwn(domInteractions, (helperFunction, key) =>
  Browser.prototype[key] = function (...args) {
    if (DEBUG) console.debug('Queueing ', helperFunction.name);
    return this.andThen(
      (rootElement) => helperFunction(rootElement, ...args),
      helperFunction.name
    );
  }
);

_.forOwn(storeInteractions, (helperFunction, key) =>
  Browser.prototype[key] = function (...args) {
    return this.andThen((rootElement, store) => {
      if (!store) {
        throw new Error('Browser context has no store instance. ' +
          'Please provide a store instance when creating a browser context.');
      }
      helperFunction(store, ...args);
    }, helperFunction.name);
  }
);
/* eslint-enable no-return-assign, func-names */

export default Browser;
