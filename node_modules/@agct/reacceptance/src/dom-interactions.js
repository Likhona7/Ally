import chai, { expect as chaiExpect } from 'chai';
import chaiEnzyme from 'chai-enzyme';
chai.use(chaiEnzyme());

function resolveSelector(rootElement, selector) {
  if (typeof(selector) === 'function') {
    return selector(rootElement);
  }
  return rootElement.find(selector);
}

export function click(rootElement, selector) {
  const button = resolveSelector(rootElement, selector);
  button.simulate('click', { button: 0 });
}

export function expect(...args) {
  if (args.length === 2) {
    const [rootElement, callback] = args;
    return callback(chaiExpect(rootElement));
  }

  const [rootElement, selector, callback] = args;
  return callback(chaiExpect(resolveSelector(rootElement, selector)));
}

export function findThen(...args) {
  if (args.length === 2) {
    const [rootElement, callback] = args;
    return callback(rootElement);
  }

  const [rootElement, selector, callback] = args;
  return callback(resolveSelector(rootElement, selector));
}

export function findItemAt(rootElement, selector, index, callback) {
  const wrapper = rootElement.find(selector).at(index);
  return callback(wrapper);
}

export function waitForElement(rootElement, selector, timeout = 2000) {
  return new Promise((resolve, reject) => {
    let timedOut = false;
    let timer;
    const pollForElement = () => {
      const matchingElements = resolveSelector(rootElement, selector);

      if (timedOut) {
        reject(new Error(`Element could not be found for ${selector}.`));
      }

      if (matchingElements.length === 0) {
        timer = setTimeout(pollForElement, 50);
      } else {
        clearTimeout(timer);
        resolve(matchingElements);
      }
    };

    pollForElement();

    setTimeout(() => { timedOut = true; }, timeout);
  });
}

export function expectItemAt(rootElement, selector, index, callback) {
  const wrapper = rootElement.find(selector).at(index);
  return callback(chaiExpect(wrapper));
}

export function expectText(rootElement, selector, value) {
  return expect(
    rootElement,
    selector,
    (element) => element.to.have.text(value)
  );
}

export function expectValue(rootElement, selector, value) {
  return expect(
    rootElement,
    selector,
    (element) => element.to.have.value(value)
  );
}

export function expectSelected(rootElement, selector, value) {
  const selectTitle = resolveSelector(rootElement, selector)
    .find('.dropdown__title');
  return chaiExpect(selectTitle).to.have.text(value);
}

export function choose(rootElement, selector) {
  const wrapper = resolveSelector(rootElement, selector);
  const value = wrapper.prop('value');
  wrapper.simulate('change', { value });
}

export function expectChosen(rootElement, selector, value = true) {
  const wrapper = resolveSelector(rootElement, selector);
  return chaiExpect(wrapper).to.have.prop('checked', value);
}

export function check(rootElement, selector) {
  const wrapper = resolveSelector(rootElement, selector);
  wrapper.simulate('change', { target: { checked: true } });
}

export function uncheck(rootElement, selector) {
  const wrapper = resolveSelector(rootElement, selector);
  wrapper.simulate('change', { target: { checked: false } });
}

export function expectChecked(rootElement, selector, value = true) {
  const wrapper = resolveSelector(rootElement, selector);
  return chaiExpect(wrapper).to.have.prop('checked', value);
}

export function fillIn(rootElement, selector, value) {
  const wrapper = resolveSelector(rootElement, selector);

  wrapper.simulate('focus');
  wrapper.simulate('change', { target: { value } });
  wrapper.simulate('blur');
}

export function select(rootElement, selector, textValue) {
  const wrapper = resolveSelector(rootElement, selector);

  const button = wrapper.find('.dropdown__toggle');
  button.simulate('click');

  const item = wrapper
    .find('div.item')
    .findWhere(i => i.text() === textValue);

  item.simulate('click');
}

export function submit(rootElement, selector) {
  resolveSelector(rootElement, selector).simulate('submit');
}

export function log(rootElement, message) {
  // eslint-disable-next-line no-console
  console.log(message);
}
